import random as rn
from genome import Genome
from tree import Tree

class Phylogeny( object ):


	def __init__( self, size=5, numChromosones=3):
		self.original = Genome()
		for c in range( numChromosones ):
			for pos in range(size):
				chromosone = ""
				for val in range( c*size, (c+1)*size ):
					chromosone += str(val)
					chromosone += " "
				self.original.addChromosone(chromosone)

		self.tree = Tree( self.original )


	def produceDescendant(self, ancestor ):
		mod = rn.choice(["DELETION", "DUPLICATION", "MOVEMENT","NONE"])
		descendant = [a for a in ancestor]

		if mod == "DELETION":
			descendant.pop( rn.randint(0,len(descendant)-1))

		elif mod == "DUPLICATION":
			dup = rn.choice( descendant )
			descendant.insert( rn.randint(0,len(descendant)-1), dup)

		elif mod == "MOVEMENT":
			dup = rn.choice( descendant )
			descendant.remove( dup )
			descendant.insert( rn.randint(0,len(descendant)-1), dup)

		elif mod == "NONE":
			pass

		return (mod, descendant)

	def mutate(self, ancestor):
		return ancestor

	def evolve(self, evolutionRate=0.5):
		tips = []
		self.tree.populateTips(tips)
		for (genome, leaf) in tips:
			if rn.random() < evolutionRate:
				newGenome = Genome( str(genome))
				mutate( newGenome )

				if rn.random() < evolutionRate:
					mutate( genome )

				leaf.addConnection( genome)
				leaf.addConnection( newGenome)





	def produceNewPhyloLayer(self):
		size= 2 * len( self.tails )

		newLayer = []
		newLayerMods = []
		for i, ancestor in enumerate(self.tails):
			for arbitrary in range(2):
				d = self.produceDescendant( ancestor )
				newLayerMods.append( (i,d[0]) )
				newLayer.append( d[1] )

		self.layers.append(newLayer)
		self.layerMods.append( newLayerMods )
		self.tails = newLayer


def  main():

	phylo = Phylogeny(4)

	for arb in range(4):
		phylo.produceNewPhyloLayer()

	for i, layer in enumerate(phylo.layers):
		print(phylo.layerMods[i])
		print(layer)
		print()

if __name__ == "__main__":
	main()





